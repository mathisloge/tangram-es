diff --git a/include/mapbox/geometry/feature.hpp b/include/mapbox/geometry/feature.hpp
index 685c012..7008198 100644
--- a/include/mapbox/geometry/feature.hpp
+++ b/include/mapbox/geometry/feature.hpp
@@ -8,7 +8,6 @@
 #include <string>
 #include <vector>
 #include <unordered_map>
-#include <experimental/optional>
 
 namespace mapbox {
 namespace geometry {
@@ -44,7 +43,7 @@ struct value : value_base
 using property_map = std::unordered_map<std::string, value>;
 
 // The same considerations and requirement for numeric types apply as for `value_base`.
-using identifier = mapbox::util::variant<uint64_t, int64_t, double, std::string>;
+using identifier = mapbox::util::variant<null_value_t, uint64_t, int64_t, double, std::string>;
 
 template <class T>
 struct feature
@@ -52,18 +51,21 @@ struct feature
     using coordinate_type = T;
     using geometry_type = mapbox::geometry::geometry<T>; // Fully qualified to avoid GCC -fpermissive error.
 
+    feature(geometry_type geometry)
+        : geometry(geometry) {}
+
+    feature(geometry_type geometry, property_map properties)
+        : geometry(geometry), properties(properties) {}
+
+    feature(geometry_type geometry, identifier id)
+        : geometry(geometry), id(id) {}
+
+    feature(geometry_type geometry, property_map properties, identifier id)
+        : geometry(geometry), properties(properties), id(id) {}
+
     geometry_type geometry;
-    property_map properties {};
-    std::experimental::optional<identifier> id {};
-
-    // GCC 4.9 does not support C++14 aggregates with non-static data member
-    // initializers.
-    feature(geometry_type geometry_,
-            property_map properties_ = property_map {},
-            std::experimental::optional<identifier> id_ = std::experimental::optional<identifier> {})
-        : geometry(std::move(geometry_)),
-          properties(std::move(properties_)),
-          id(std::move(id_)) {}
+    property_map properties;
+    identifier id;
 };
 
 template <class T>
@@ -84,12 +86,7 @@ struct feature_collection : Cont<feature<T>>
     using coordinate_type = T;
     using feature_type = feature<T>;
     using container_type = Cont<feature_type>;
-    using size_type = typename container_type::size_type;
-
-    template <class... Args>
-    feature_collection(Args&&... args) : container_type(std::forward<Args>(args)...) {}
-    feature_collection(std::initializer_list<feature_type> args)
-        : container_type(std::move(args)) {}
+    using container_type::container_type;
 };
 
 } // namespace geometry
